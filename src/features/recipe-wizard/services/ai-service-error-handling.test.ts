/**
 * @fileoverview Error Handling and Fallback Tests for Recipe Wizard AI Services
 * Tests streaming failures, retry logic, and user-friendly error messages
 */

import { fetchPotentialCauses, AIServiceError } from './ai-service';
import { fetchPotentialCausesStreaming, StreamingAIServiceError } from './ai-service-streaming';
import { useAIStreaming } from '../../../lib/ai/hooks/use-ai-streaming';
import { renderHook, act } from '@testing-library/react';

// Mock fetch for API calls
global.fetch = jest.fn();

// Mock EventSource for streaming tests
class MockEventSource {
  public onopen: ((event: Event) => void) | null = null;
  public onmessage: ((event: MessageEvent) => void) | null = null;
  public onerror: ((event: Event) => void) | null = null;
  public readyState: number = 0;
  public url: string;

  constructor(url: string) {
    this.url = url;
    // Simulate async connection
    setTimeout(() => {
      this.readyState = 1;
      if (this.onopen) {
        this.onopen(new Event('open'));
      }
    }, 10);
  }

  close() {
    this.readyState = 2;
  }

  // Helper methods for testing
  simulateMessage(data: string) {
    if (this.onmessage) {
      this.onmessage(new MessageEvent('message', { data }));
    }
  }

  simulateError() {
    if (this.onerror) {
      this.onerror(new Event('error'));
    }
  }
}

// Mock EventSource globally
(global as any).EventSource = MockEventSource;

describe('Error Handling and Fallback Tests', () => {
  const mockRequest = {
    healthConcern: 'I have chronic anxiety and stress',
    demographics: {
      gender: 'female' as const,
      ageCategory: 'adult' as const,
      specificAge: 32,
      language: 'EN_US' as const
    }
  };

  beforeEach(() => {
    jest.clearAllMocks();
    (global.fetch as jest.Mock).mockClear();
    jest.useFakeTimers();
  });

  afterEach(() => {
    jest.useRealTimers();
  });

  describe('Original AI Service Error Handling', () => {
    it('should handle network failures gracefully', async () => {
      (global.fetch as jest.Mock).mockRejectedValueOnce(new TypeError('fetch failed'));

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow(AIServiceError);

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow('Network error: Unable to connect to AI service');
    });

    it('should handle API server errors with user-friendly messages', async () => {
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: async () => ({ error: 'Internal server error' })
      });

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow(AIServiceError);

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow('Internal server error');
    });

    it('should handle API timeout scenarios', async () => {
      (global.fetch as jest.Mock).mockImplementationOnce(() => 
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Request timeout')), 100)
        )
      );

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow(AIServiceError);
    });

    it('should handle malformed API responses', async () => {
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true, data: 'not an array' })
      });

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow('Invalid response format from API');
    });

    it('should handle empty API responses', async () => {
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true, data: [] })
      });

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow('No potential causes generated by AI service');
    });

    it('should handle API rate limiting', async () => {
      (global.fetch as jest.Mock).mockResolvedValueOnce({
        ok: false,
        status: 429,
        json: async () => ({ error: 'Rate limit exceeded' })
      });

      await expect(fetchPotentialCauses(mockRequest))
        .rejects
        .toThrow('Rate limit exceeded');
    });
  });

  describe('Streaming AI Service Error Handling', () => {
    it('should handle streaming connection failures', async () => {
      const streamingResponse = await fetchPotentialCausesStreaming(mockRequest);
      
      expect(streamingResponse.error).toBeNull();
      expect(streamingResponse.isStreaming).toBe(false);
      
      // Simulate connection failure
      await act(async () => {
        await streamingResponse.startStream('/api/ai/streaming');
      });

      // The streaming should handle connection errors gracefully
      expect(typeof streamingResponse.resetStream).toBe('function');
    });

    it('should provide user-friendly error messages for streaming failures', async () => {
      const streamingResponse = await fetchPotentialCausesStreaming(mockRequest);
      
      // Test that error messages are user-friendly
      expect(streamingResponse.error).toBeNull();
      
      // The streaming response should have error handling capabilities
      expect(streamingResponse).toHaveProperty('error');
      expect(streamingResponse).toHaveProperty('resetStream');
    });

    it('should handle invalid streaming request data', async () => {
      const invalidRequest = {
        healthConcern: '',
        demographics: null as any
      };

      await expect(fetchPotentialCausesStreaming(invalidRequest))
        .rejects
        .toThrow(StreamingAIServiceError);

      await expect(fetchPotentialCausesStreaming(invalidRequest))
        .rejects
        .toThrow('Health concern is required');
    });
  });

  describe('useAIStreaming Hook Error Handling', () => {
    it('should handle connection timeouts with retry logic', async () => {
      const { result } = renderHook(() => useAIStreaming({
        maxRetries: 2,
        retryDelay: 100,
        timeout: 200
      }));

      expect(result.current.error).toBeNull();
      expect(result.current.isStreaming).toBe(false);

      // Start streaming
      await act(async () => {
        await result.current.startStream('/api/ai/streaming', {
          feature: 'recipe-wizard',
          step: 'potential-causes',
          data: mockRequest
        });
      });

      // Fast-forward past timeout
      act(() => {
        jest.advanceTimersByTime(300);
      });

      // Should handle timeout gracefully
      expect(result.current.isStreaming).toBe(false);
    });

    it('should implement exponential backoff for retries', async () => {
      const { result } = renderHook(() => useAIStreaming({
        maxRetries: 3,
        retryDelay: 100,
        timeout: 5000
      }));

      // Mock console.log to verify retry logic
      const consoleSpy = jest.spyOn(console, 'log').mockImplementation();

      await act(async () => {
        await result.current.startStream('/api/ai/streaming', {
          feature: 'recipe-wizard',
          step: 'potential-causes',
          data: mockRequest
        });
      });

      // Simulate connection error to trigger retry
      const eventSource = (global as any).EventSource.mock?.instances?.[0];
      if (eventSource) {
        act(() => {
          eventSource.simulateError();
        });

        // Fast-forward to trigger first retry
        act(() => {
          jest.advanceTimersByTime(100);
        });

        // Verify retry logic is called
        expect(consoleSpy).toHaveBeenCalledWith(
          expect.stringContaining('Retrying connection (attempt 1/3)')
        );
      }

      consoleSpy.mockRestore();
    });

    it('should stop retrying after max attempts and show user-friendly error', async () => {
      const { result } = renderHook(() => useAIStreaming({
        maxRetries: 2,
        retryDelay: 50,
        timeout: 5000
      }));

      await act(async () => {
        await result.current.startStream('/api/ai/streaming', {
          feature: 'recipe-wizard',
          step: 'potential-causes',
          data: mockRequest
        });
      });

      // Simulate multiple connection failures
      const eventSource = (global as any).EventSource.mock?.instances?.[0];
      if (eventSource) {
        // First failure
        act(() => {
          eventSource.simulateError();
        });
        act(() => {
          jest.advanceTimersByTime(50);
        });

        // Second failure
        act(() => {
          eventSource.simulateError();
        });
        act(() => {
          jest.advanceTimersByTime(100);
        });

        // Third failure (should exceed max retries)
        act(() => {
          eventSource.simulateError();
        });
        act(() => {
          jest.advanceTimersByTime(200);
        });
      }

      // Should have user-friendly error message
      expect(result.current.isStreaming).toBe(false);
      expect(result.current.error).toBeTruthy();
    });

    it('should handle malformed SSE events gracefully', async () => {
      const { result } = renderHook(() => useAIStreaming());

      await act(async () => {
        await result.current.startStream('/api/ai/streaming', {
          feature: 'recipe-wizard',
          step: 'potential-causes',
          data: mockRequest
        });
      });

      const eventSource = (global as any).EventSource.mock?.instances?.[0];
      if (eventSource) {
        // Send malformed JSON
        act(() => {
          eventSource.simulateMessage('data: {invalid json}');
        });

        // Should handle parsing error gracefully
        expect(result.current.error).toBeTruthy();
        expect(result.current.isStreaming).toBe(false);
      }
    });

    it('should reset error state when starting new stream', async () => {
      const { result } = renderHook(() => useAIStreaming());

      // First, create an error state
      await act(async () => {
        await result.current.startStream('/api/ai/streaming', {
          feature: 'recipe-wizard',
          step: 'potential-causes',
          data: mockRequest
        });
      });

      // Simulate error
      const eventSource = (global as any).EventSource.mock?.instances?.[0];
      if (eventSource) {
        act(() => {
          eventSource.simulateMessage('data: {"type": "error", "message": "Test error"}');
        });
      }

      expect(result.current.error).toBeTruthy();

      // Reset and start new stream
      act(() => {
        result.current.resetStream();
      });

      expect(result.current.error).toBeNull();
      expect(result.current.isStreaming).toBe(false);
      expect(result.current.streamingText).toBe('');
    });
  });

  describe('Error Recovery and User Experience', () => {
    it('should provide clear error messages for different failure types', () => {
      const networkError = new AIServiceError(
        'Network error: Unable to connect to AI service',
        'NETWORK_ERROR',
        new TypeError('fetch failed')
      );

      const timeoutError = new StreamingAIServiceError(
        'Request timeout: AI analysis took too long',
        'TIMEOUT_ERROR'
      );

      expect(networkError.message).toContain('Network error');
      expect(timeoutError.message).toContain('timeout');
      expect(networkError.code).toBe('NETWORK_ERROR');
      expect(timeoutError.code).toBe('TIMEOUT_ERROR');
    });

    it('should maintain error context for debugging', () => {
      const originalError = new Error('Original fetch error');
      const wrappedError = new AIServiceError(
        'Failed to fetch potential causes',
        'FETCH_ERROR',
        originalError
      );

      expect(wrappedError.originalError).toBe(originalError);
      expect(wrappedError.code).toBe('FETCH_ERROR');
      expect(wrappedError.message).toBe('Failed to fetch potential causes');
    });

    it('should provide recovery suggestions in error messages', async () => {
      const { result } = renderHook(() => useAIStreaming({
        maxRetries: 1,
        retryDelay: 50
      }));

      await act(async () => {
        await result.current.startStream('/api/ai/streaming', {
          feature: 'recipe-wizard',
          step: 'potential-causes',
          data: mockRequest
        });
      });

      // Simulate connection failure
      const eventSource = (global as any).EventSource.mock?.instances?.[0];
      if (eventSource) {
        act(() => {
          eventSource.simulateError();
        });
        act(() => {
          jest.advanceTimersByTime(100);
        });
        act(() => {
          eventSource.simulateError();
        });
      }

      // Error message should suggest recovery action
      expect(result.current.error).toContain('retry');
    });
  });

  describe('Fallback Mechanisms', () => {
    it('should allow fallback to non-streaming service when streaming fails', async () => {
      // Test that both services can be used as fallbacks for each other
      const streamingResponse = await fetchPotentialCausesStreaming(mockRequest);
      
      // If streaming fails, we should be able to fall back to regular service
      expect(streamingResponse).toBeDefined();
      expect(typeof fetchPotentialCauses).toBe('function');
      
      // Both should handle the same request format
      expect(streamingResponse.startStream).toBeDefined();
    });

    it('should maintain consistent error handling between streaming and non-streaming', async () => {
      // Both services should handle the same error scenarios consistently
      const invalidRequest = {
        healthConcern: '',
        demographics: mockRequest.demographics
      };

      // Both should throw similar errors for invalid input
      await expect(fetchPotentialCauses(invalidRequest))
        .rejects
        .toThrow(AIServiceError);

      await expect(fetchPotentialCausesStreaming(invalidRequest))
        .rejects
        .toThrow(StreamingAIServiceError);
    });
  });
});
